#!/usr/bin/greyhole-php
<?php
/*
Copyright 2009-2020 Guillaume Boudreau, Andrew Hopkinson

This file is part of Greyhole.

Greyhole is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Greyhole is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Greyhole.  If not, see <http://www.gnu.org/licenses/>.
*/

require_once('includes/common.php');
require_once('includes/CLI/CommandLineHelper.php'); // Command line helper (abstract classes, command line definitions & parsing, Runners, etc.)
require_once('includes/DaemonRunner.php');

// This will parse the command line, and find commands and options.
// It will then instantiate the appropriate class (that extends AbstractRunner), and return it.
$cliHelper = new CommandLineHelper();
$runner = $cliHelper->processCommandLine();

// This will run the runner(!) i.e. what the user asked for will now be executed.
$runner->run();

// The runner has finished; let's clean up before quitting.
$runner->finish();

function gh_check_file_locked($share, $target_full_path) {
    $idx = clean_dir("$share/$target_full_path");
    $locked_by = DBSpool::isFileLocked($idx);
    if (!$locked_by) {
        $locked_by = file_is_locked($share, $target_full_path);
        if ($locked_by !== FALSE) {
            DBSpool::lockFile($idx, $locked_by);
        }
    }
    if ($locked_by !== FALSE) {
        Log::debug("  File $share/$target_full_path is locked by another process ($locked_by). Will wait until it's unlocked to work on any file in this share.");
        DBSpool::lockShare($share);
        return TRUE;
    }
    return FALSE;
}

function fix_symlinks($landing_zone, $share, $full_path, $target_full_path) {
    global $fix_symlinks_scanned_dirs;
    if (isset($fix_symlinks_scanned_dirs[$landing_zone])) {
        return;
    }
    Log::info("  Scanning $landing_zone for broken links... This can take a while!");
    exec("find -L " . escapeshellarg($landing_zone) . " -type l", $broken_links);
    Log::debug("    Found " . count($broken_links) . " broken links.");
    foreach ($broken_links as $broken_link) {
        $fixed_link_target = readlink($broken_link);
        Log::debug("    Found a broken symlink to update: $broken_link. Broken target: $fixed_link_target");
        foreach (Config::storagePoolDrives() as $sp_drive) {
            $fixed_link_target = str_replace(clean_dir("$sp_drive/$share/$full_path/"), clean_dir("$sp_drive/$share/$target_full_path/"), $fixed_link_target);
            if ($fixed_link_target == "$sp_drive/$share/$full_path") {
                $fixed_link_target = "$sp_drive/$share/$target_full_path";
                break;
            }
        }
        if (gh_is_file($fixed_link_target)) {
            Log::debug("      New (fixed) target: $fixed_link_target");
            unlink($broken_link);
            gh_symlink($fixed_link_target, $broken_link);
        }
    }
    $fix_symlinks_scanned_dirs[$landing_zone] = TRUE;
}

function gh_file_exists($real_path, $log_message=null) {
    clearstatcache();
    if (!file_exists($real_path)) {
        if ($log_message != null) {
            eval('$log_message = "' . str_replace('"', '\"', $log_message) . '";');
            Log::info($log_message);
        }
        return FALSE;
    }
    return TRUE;
}

function get_num_copies($share) {
    $num_copies = SharesConfig::get($share, CONFIG_NUM_COPIES);
    if (!$num_copies) {
        Log::warn("Found a task on a share ($share) that disappeared from " . ConfigHelper::$config_file . ". Skipping.", Log::EVENT_CODE_TASK_FOR_UNKNOWN_SHARE);
        return -1;
    }
    if ($num_copies < 1) {
        $num_copies = 1;
    }
    $max_copies = 0;
    foreach (Config::storagePoolDrives() as $sp_drive) {
        if (StoragePool::is_pool_drive($sp_drive)) {
            $max_copies++;
        }
    }
    if ($num_copies > $max_copies) {
        $num_copies = $max_copies;
    }
    return $num_copies;
}

function file_is_locked($share, $full_path) {
    if (Config::get(CONFIG_CHECK_FOR_OPEN_FILES) === FALSE) {
        Log::debug("  Skipping open file (lock) check.");
        return FALSE;
    }
    
    $landing_zone = get_share_landing_zone($share);
    if (!$landing_zone) {
        return FALSE;
    }
    
    $real_fullpath = "$landing_zone/$full_path";
    if (is_link($real_fullpath)) {
        $real_fullpath = readlink($real_fullpath);
    }
    $result = exec("lsof -M -n -P -l " . escapeshellarg($real_fullpath) . " 2> /dev/null");
    if (string_contains($result, $real_fullpath)) {
        return $result;
    }

    $query = "SELECT * FROM tasks WHERE complete = 'no' AND action = 'write' AND share = :share AND full_path = :full_path LIMIT 1";
    $params = array('share' => $share, 'full_path' => $full_path);
    $row = DB::getFirst($query, $params);
    if ($row === FALSE) {
        return FALSE;
    }
    
    // Locked, according to DB... But maybe it's not really locked?
    if (!gh_file_exists($real_fullpath)) {
        // File doesn't exists anymore... It can't be really locked... Let's assume this is just Samba that 'forgot' to close the file handle.
        $query = "UPDATE tasks SET complete = 'yes' WHERE complete = 'no' AND action = 'write' AND share = :share AND full_path = :full_path";
        DB::execute($query, $params);
        return FALSE;
    }

    return 'samba-vfs-writer';
}

function real_file_is_locked($real_fullpath) {
    if (is_link($real_fullpath)) {
        $real_fullpath = readlink($real_fullpath);
    }
    $result = exec("lsof -M -n -P -l " . escapeshellarg($real_fullpath) . " 2> /dev/null");
    if (string_contains($result, $real_fullpath)) {
        return $result;
    }
    return FALSE;
}

function find_future_full_path($share, $full_path, $task_id) {
    $new_full_path = $full_path;
    while ($next_task = DBSpool::getInstance()->find_next_rename_task($share, $new_full_path, $task_id)) {
        if ($next_task->full_path == $full_path) {
            // File was renamed
            $new_full_path = $next_task->additional_info;
        } else {
            // A parent directory was renamed
            $new_full_path = preg_replace("@^$next_task->full_path@", $next_task->additional_info, $new_full_path);
        }
        $task_id = $next_task->id;
    }
    return $new_full_path;
}

function should_ignore_file($share, $full_path) {
    list($path, $filename) = explode_full_path($full_path);

    foreach (Config::get(CONFIG_IGNORED_FILES) as $ignored_file_re) {
        if (preg_match(';^' . $ignored_file_re . '$;', $filename)) {
            Log::info("Ignoring task because it matches the following '" . CONFIG_IGNORED_FILES . "' pattern: $ignored_file_re");
            return TRUE;
        }
    }
    foreach (Config::get(CONFIG_IGNORED_FOLDERS) as $ignored_folder_re) {
        $p = clean_dir("$share/$path/");
        if (preg_match(';^' . $ignored_folder_re . '$;', $p)) {
            Log::info("Ignoring task because it matches the following '" . CONFIG_IGNORED_FOLDERS . "' pattern: $ignored_folder_re");
            return TRUE;
        }
    }

    return FALSE;
}

function create_copies_from_metafiles($metafiles, $share, $full_path, $source_file, $missing_only=FALSE) {
    $landing_zone = get_share_landing_zone($share);
    
    list($path, $filename) = explode_full_path($full_path);
    
    $source_file = clean_dir($source_file);

    $link_next = FALSE;
    foreach ($metafiles as $key => $metafile) {
        if (!gh_file_exists("$landing_zone/$full_path", '  $real_path doesn\'t exist anymore. Aborting.')) { return FALSE; }
        
        if ($metafile->path == $source_file && $metafile->state == Metafile::STATE_OK && gh_filesize($metafile->path) == gh_filesize($source_file)) {
            Log::debug("  File copy at $metafile->path is already up to date.");
            continue;
        }
        
        if ($missing_only && gh_file_exists($metafile->path) && $metafile->state == Metafile::STATE_OK && gh_filesize($metafile->path) == gh_filesize($source_file)) {
            Log::debug("  File copy at $metafile->path is already up to date.");
            continue;
        }

        $root_path = str_replace(clean_dir("/$share/$full_path"), '', $metafile->path);
        if (!StoragePool::is_pool_drive($root_path)) {
            Log::warn("  Warning! It seems the partition UUID of $root_path changed. This probably means this mount is currently unmounted, or that you replaced this drive and didn't use 'greyhole --replace'. Because of that, Greyhole will NOT use this drive at this time.", Log::EVENT_CODE_STORAGE_POOL_DRIVE_UUID_CHANGED);
            $metafile->state = Metafile::STATE_GONE;
            $metafiles[$key] = $metafile;
            continue;
        }

        list($metafile_dir_path, ) = explode_full_path($metafile->path);

        list($original_path, ) = explode_full_path(get_share_landing_zone($share) . "/$full_path");
        if (!gh_mkdir($metafile_dir_path, $original_path)) {
            $metafile->state = Metafile::STATE_GONE;
            $metafiles[$key] = $metafile;
            continue;
        }

        if (!gh_copy_file($source_file, $metafile->path)) {
            if ($metafile->is_linked) {
                $metafile->is_linked = FALSE;
                $link_next = TRUE;
                if (@readlink("$landing_zone/$full_path") == $metafile->path) {
                    // Symlink in landing zone is pointing to this file copy; we need to remove it, otherwise, we'd end up with a broken symlink after gh_recycle()
                    Log::debug("  Deleting symlink from landing zone, before recycling the file copy it points to.");
                    unlink("$landing_zone/$full_path");
                }
            }
            $metafile->state = Metafile::STATE_GONE;
            gh_recycle($metafile->path);
            $metafiles[$key] = $metafile;
            Metastores::save_metafiles($share, $path, $filename, $metafiles);

            if (file_exists("$landing_zone/$full_path")) {
                if (DBSpool::isCurrentTaskRetry()) {
                    Log::error("    Failed file copy (cont). We already retried this task. Aborting.", Log::EVENT_CODE_FILE_COPY_FAILED);
                    return FALSE;
                }
                Log::warn("    Failed file copy (cont). Will try to re-process this write task, since the source file seems intact.", Log::EVENT_CODE_FILE_COPY_FAILED);
                // Queue a new write task, to replace the now gone copy.
                DBSpool::setNextTask(
                    (object) array(
                        'id' => 0,
                        'action' => 'write',
                        'share' => $share,
                        'full_path' => clean_dir($full_path),
                        'complete' => 'yes'
                    )
                );
                return FALSE;
            }
            continue;
        }

        if ($link_next && !$metafile->is_linked) {
            $metafile->is_linked = TRUE;
            $metafiles[$key] = $metafile;
        }
        $link_next = FALSE;
        if ($metafile->is_linked) {
            Log::debug("    Creating symlink in share pointing to the above file copy.");
            gh_symlink($metafile->path, "$landing_zone/$path/.gh_$filename");
            if (!file_exists("$landing_zone/$full_path") || unlink("$landing_zone/$full_path")) {
                gh_rename("$landing_zone/$path/.gh_$filename", "$landing_zone/$path/$filename");
            } else {
                unlink("$landing_zone/$path/.gh_$filename");
            }
        }

        if (gh_file_exists($metafile->path, '  Copy at $real_path doesn\'t exist. Will not mark it OK!')) {
            $metafile->state = Metafile::STATE_OK;
            $metafiles[$key] = $metafile;
        }
        Metastores::save_metafiles($share, $path, $filename, $metafiles);
    }
    return TRUE;
}

function gh_copy_file($source_file, &$destination_file) {
    if (gh_is_file($source_file) && $source_file == $destination_file) {
        Log::debug("  Destination $destination_file is the same as the source. Nothing to do here; this file copy is ready!");
        return TRUE;
    }

    $start_time = time();
    $source_size = gh_filesize($source_file);
    $temp_path = get_temp_filename($destination_file);

    if (is_link($source_file)) {
        $link_target = readlink($source_file);
        $source_size = gh_filesize($link_target);
    } else if (gh_is_file($source_file)) {
        $source_size = gh_filesize($source_file);
    }

    if (isset($source_size)) {
        Log::debug("  Copying " . bytes_to_human($source_size, FALSE) . " file to $destination_file");
    } else {
        Log::debug("  Copying file to $destination_file");
    }

    $renamed = FALSE;
    if (gh_is_file($source_file)) {
        $source_dev = gh_file_deviceid($source_file);
        $target_dev = gh_file_deviceid(dirname($destination_file));
        if ($source_dev === $target_dev && $source_dev !== FALSE && !Config::get(CONFIG_ALLOW_MULTIPLE_SP_PER_DRIVE)) {
            Log::debug("  (using rename)");
            $original_file_infos = gh_get_file_infos($source_file);
            gh_rename($source_file, $temp_path);
            $renamed = TRUE;
        }
    }

    if (!$renamed) {
        // Wasn't renamed; need to be copied.
        $copy_source = is_link($source_file) ? readlink($source_file) : $source_file;
        $original_file_infos = gh_get_file_infos($copy_source);
        $copy_cmd = "cat " . escapeshellarg($copy_source) . " | tee " . escapeshellarg($temp_path) . " | md5sum";
        $out = exec($copy_cmd);
        $md5 = first(explode(' ', $out));
        Log::debug("    Copied file MD5 = $md5");
    }

    $it_worked = file_exists($temp_path) && ($renamed || file_exists($source_file)) && gh_filesize($temp_path) == $source_size;
    if (!$it_worked) {
        // Try NFC form [http://en.wikipedia.org/wiki/Unicode_equivalence#Normalization]
        $it_worked = file_exists(normalize_utf8_characters($temp_path)) && ($renamed || file_exists($source_file)) && gh_filesize($temp_path) == $source_size;
        if ($it_worked) {
            // Bingo!
            $temp_path = normalize_utf8_characters($temp_path);
            $destination_file = normalize_utf8_characters($destination_file);
        }
    }
    if ($it_worked) {
        if (time() - $start_time > 0) {
            $speed = number_format($source_size/1024/1024 / (time() - $start_time), 1);
            Log::debug("    Copy created at $speed MBps.");
        }
        gh_rename($temp_path, $destination_file);
        /** @noinspection PhpUndefinedVariableInspection */
        gh_chperm($destination_file, $original_file_infos);
        if (!empty($md5)) {
            /** @noinspection PhpUndefinedVariableInspection */
            list($share, $full_path) = get_share_and_fullpath_from_realpath($copy_source);
            log_file_checksum($share, $full_path, $md5);
        }
    } else {
        Log::warn("    Failed file copy. Will mark this metadata file 'Gone'.", Log::EVENT_CODE_FILE_COPY_FAILED);
        if ($renamed) {
            // Do NOT delete $temp_path if the file was renamed... Just move it back!
            gh_rename($temp_path, $source_file);
        } else {
            // Remove the failed copy, if any.
            @unlink($temp_path);
        }
    }
    return $it_worked;
}

function gh_chperm($real_file_path, $file_infos) {
    chmod($real_file_path, $file_infos->fileperms);
    chown($real_file_path, $file_infos->fileowner);
    chgrp($real_file_path, $file_infos->filegroup);
    touch($real_file_path, $file_infos->filemtime, time());
}

function gh_mkdir($directory, $original_directory_or_dir_infos) {
    if (is_string($original_directory_or_dir_infos)) {
        $dir_infos = gh_get_file_infos($original_directory_or_dir_infos);
    } else {
        $dir_infos = $original_directory_or_dir_infos;
    }
    if (is_dir($directory)) {
        if (!chown($directory, $dir_infos->fileowner)) {
            Log::warn("  Failed to chown directory '$directory'", Log::EVENT_CODE_MKDIR_CHOWN_FAILED);
        }
        if (!chgrp($directory, $dir_infos->filegroup)) {
            Log::warn("  Failed to chgrp directory '$directory'", Log::EVENT_CODE_MKDIR_CHGRP_FAILED);
        }
        if (!chmod($directory, $dir_infos->fileperms)) {
            Log::warn("  Failed to chmod directory '$directory'", Log::EVENT_CODE_MKDIR_CHMOD_FAILED);
        }
    } else {
        // Need to mkdir & chown/chgrp all dirs that don't exists, up to the full path ($directory)
        $dir_parts = explode('/', $directory);
        
        $i = 0;
        $parent_directory = clean_dir('/' . $dir_parts[$i++]);
        while (is_dir($parent_directory) && $i < count($dir_parts)) {
            $parent_directory = clean_dir($parent_directory . '/' . $dir_parts[$i++]);
        }
        while ($i <= count($dir_parts)) {
            if (!is_dir($parent_directory) && !@mkdir($parent_directory, $dir_infos->fileperms)) {
                if (gh_is_file($parent_directory)) {
                    gh_rename($parent_directory, "$parent_directory (file copy)");
                }
                if (!@mkdir($parent_directory, $dir_infos->fileperms)) {
                    // Even if mkdir return false, the folder might have been correctly created... who would think...
                    if (!is_dir($parent_directory)) {
                        // Try NFC form [http://en.wikipedia.org/wiki/Unicode_equivalence#Normalization]
                        if (is_dir(normalize_utf8_characters($parent_directory))) {
                            // Bingo!
                            $parent_directory = normalize_utf8_characters($parent_directory);
                        } else {
                            Log::warn("  Failed to create directory $parent_directory", Log::EVENT_CODE_MKDIR_FAILED);
                            return FALSE;
                        }
                    }
                }
            }
            if (!chown($parent_directory, $dir_infos->fileowner)) {
                Log::warn("  Failed to chown directory '$parent_directory'", Log::EVENT_CODE_MKDIR_CHOWN_FAILED);
            }
            if (!chgrp($parent_directory, $dir_infos->filegroup)) {
                Log::warn("  Failed to chgrp directory '$parent_directory'", Log::EVENT_CODE_MKDIR_CHGRP_FAILED);
            }
            if (!isset($dir_parts[$i])) {
                break;
            }
            $parent_directory = clean_dir($parent_directory . '/' . $dir_parts[$i++]);
        }
    }
    return TRUE;
}

function get_temp_filename($full_path) {
    list($path, $filename) = explode_full_path($full_path);
    return "$path/.$filename." . mb_substr(md5($filename), 0, 5);
}

function is_temp_file($full_path) {
    list(, $filename) = explode_full_path($full_path);
    if (preg_match("/^\.(.+)\.([0-9a-f]{5})$/", $filename, $regs)) {
        $md5_stem = mb_substr(md5($regs[1]), 0, 5);
        return ($md5_stem == $regs[2]);
    }
    return FALSE;
}

// Cached df results
$last_df_time = 0;
$last_dfs = array();
function get_free_space_in_storage_pool_drives() {
    global $last_df_time, $last_dfs;
    if ($last_df_time > time() - Config::get(CONFIG_DF_CACHE_TIME)) {
        return $last_dfs;
    }
    $dfs = array();
    exec(ConfigHelper::$df_command, $responses);
    $responses_arr = array();
    foreach ($responses as $line) {
        if (preg_match("@\s+[0-9]+\s+([0-9]+)\s+([0-9]+)\s+[0-9]+%\s+(.+)$@", $line, $regs)) {
                $responses_arr[] = array((float) $regs[1], (float) $regs[2], $regs[3]);
        }
    }
    $responses = $responses_arr;
    foreach (Config::storagePoolDrives() as $sp_drive) {
        if (!StoragePool::is_pool_drive($sp_drive)) {
            continue;
        }
        $target_drive = '';
        for ($i=0; $i<count($responses); $i++) {
            $used_space = $responses[$i][0];
            $free_space = $responses[$i][1];
            $mount = $responses[$i][2];
            if (mb_strpos($sp_drive, $mount) === 0 && mb_strlen($mount) > mb_strlen($target_drive)) {
                $target_drive = $mount;
                $target_freespace = $free_space;
                $target_usedspace = $used_space;
            }
        }
        /** @noinspection PhpUndefinedVariableInspection */
        $dfs[$sp_drive]['free'] = $target_freespace;
        /** @noinspection PhpUndefinedVariableInspection */
        $dfs[$sp_drive]['used'] = $target_usedspace;
    }
    $last_df_time = time();
    $last_dfs = $dfs;
    return $dfs;
}

function order_target_drives($filesize_kb, $include_full_drives, $share, $path, $log_prefix='', &$is_sticky=NULL) {
    global $last_OOS_notification;

    foreach (SharesConfig::get($share, CONFIG_DRIVE_SELECTION_ALGORITHM) as $ds) {
        $algo = $ds->selection_algorithm;
        break;
    }

    $dfs = get_free_space_in_storage_pool_drives();

    $sorted_target_drives = array('available_space' => array(), 'used_space' => array());
    $last_resort_sorted_target_drives = array('available_space' => array(), 'used_space' => array());
    $full_drives = array();
    foreach (Config::storagePoolDrives() as $sp_drive) {
        if (!isset($dfs[$sp_drive])) {
            if (!is_dir($sp_drive)) {
                if (SystemHelper::is_amahi()) {
                    $details = "You should de-select, then re-select this partition in your Amahi dashboard (http://hda), in the Shares > Storage Pool page, to fix this problem.";
                } else {
                    $details = "See the INSTALL file for instructions on how to prepare partitions to include in your storage pool.";
                }
                Log::error("The directory at $sp_drive doesn't exist. This drive will never be used! $details", Log::EVENT_CODE_STORAGE_POOL_FOLDER_NOT_FOUND);
            } else if (!file_exists("$sp_drive/.greyhole_used_this") && StoragePool::is_pool_drive($sp_drive)) {
                unset($df_command_responses);
                exec(ConfigHelper::$df_command, $df_command_responses);
                unset($df_k_responses);
                exec('df -k 2>&1', $df_k_responses);
                $details = "Please report this using the 'Issues' tab found on https://github.com/gboudreau/Greyhole. You should include the following information in your ticket:\n"
                    . "===== Error report starts here =====\n"
                    . "Unknown free space for partition: $sp_drive\n"
                    . "df_command: " . ConfigHelper::$df_command . "\n"
                    . "Result of df_command: " . var_export($df_command_responses, TRUE) . "\n"
                    . "Result of df -k: " . var_export($df_k_responses, TRUE) . "\n"
                    . "===== Error report ends here =====";
                Log::error("Can't find how much free space is left on $sp_drive. This partition will never be used! Details will follow.\n$details", Log::EVENT_CODE_STORAGE_POOL_DRIVE_DF_FAILED);
            }
            continue;
        }
        if (!StoragePool::is_pool_drive($sp_drive)) {
            continue;
        }
        $free_space = $dfs[$sp_drive]['free'];
        $used_space = $dfs[$sp_drive]['used'];
        $minimum_free_space = (float) Config::get(CONFIG_MIN_FREE_SPACE_POOL_DRIVE, $sp_drive);
        $available_space = (float) $free_space - $minimum_free_space;
        if ($available_space <= $filesize_kb) {
            if ($free_space > $filesize_kb) {
                $last_resort_sorted_target_drives['available_space'][$sp_drive] = $available_space;
                $last_resort_sorted_target_drives['used_space'][$sp_drive] = $used_space;
            } else {
                $full_drives[$sp_drive] = $free_space;
            }
            continue;
        }
        $sorted_target_drives['available_space'][$sp_drive] = $available_space;
        $sorted_target_drives['used_space'][$sp_drive] = $used_space;
    }

    /** @var $drives_selectors PoolDriveSelector[] */
    $drives_selectors = SharesConfig::get($share, CONFIG_DRIVE_SELECTION_ALGORITHM);
    foreach ($drives_selectors as $ds) {
        $s = $sorted_target_drives;
        $l = $last_resort_sorted_target_drives;
        $ds->init($s, $l);
    }

    $sorted_target_drives = array();
    $last_resort_sorted_target_drives = array();
    $got_all_drives = FALSE;
    while (!$got_all_drives) {
        $num_empty_ds = 0;
        global $is_forced;
        foreach ($drives_selectors as $ds) {
            $is_forced = $ds->isForced();
            list($drives, $drives_last_resort) = $ds->draft();
            foreach ($drives as $sp_drive => $space) {
                $sorted_target_drives[$sp_drive] = $space;
            }
            foreach ($drives_last_resort as $sp_drive => $space) {
                $last_resort_sorted_target_drives[$sp_drive] = $space;
            }
            if (count($drives) == 0 && count($drives_last_resort) == 0) {
                $num_empty_ds++;
            }
        }
        if ($num_empty_ds == count($drives_selectors)) {
            // All DS are empty; exit.
            break;
        }
    }
    
    // Email notification when all drives are over-capacity
    if (count($sorted_target_drives) == 0) {
        Log::error("  Warning! All storage pool drives are over-capacity!", Log::EVENT_CODE_ALL_DRIVES_FULL);
        if (!isset($last_OOS_notification)) {
            $setting = Settings::get('last_OOS_notification');
            if ($setting === FALSE) {
                Log::warn("Received no rows when querying settings for 'last_OOS_notification'; expected one.", Log::EVENT_CODE_SETTINGS_READ_ERROR);
                $setting = Settings::set('last_OOS_notification', 0);
            }
            $last_OOS_notification = $setting;
        }
        if ($last_OOS_notification < strtotime('-1 day')) {
            $email_to = Config::get(CONFIG_EMAIL_TO);

            Log::info("  Sending email notification to $email_to");

            $hostname = exec('hostname');
            $body = "This is an automated email from Greyhole.

It appears all the defined storage pool drives are over-capacity.
You probably want to do something about this!

";
            foreach ($last_resort_sorted_target_drives as $sp_drive => $free_space) {
                $minimum_free_space = (int) Config::get(CONFIG_MIN_FREE_SPACE_POOL_DRIVE, $sp_drive) / 1024 / 1024;
                $body .= "$sp_drive has " . number_format($free_space/1024/1024, 2) . " GB free; minimum specified in greyhole.conf: $minimum_free_space GB.\n";
            }
            mail($email_to, "Greyhole is out of space on $hostname!", $body);
            
            $last_OOS_notification = time();
            Settings::set('last_OOS_notification', $last_OOS_notification);
        }
    }
    
    if (Log::getLevel() >= Log::DEBUG) {
        if (count($sorted_target_drives) > 0) {
            $log = $log_prefix ."Drives with available space: ";
            foreach ($sorted_target_drives as $sp_drive => $space) {
                /** @noinspection PhpUndefinedVariableInspection */
                $log .= "$sp_drive (" . bytes_to_human($space*1024, FALSE) . " " . ($algo == 'most_available_space' ? 'avail' : 'used') . ") - ";
            }
            Log::debug(mb_substr($log, 0, mb_strlen($log)-2));
        }
        if (count($last_resort_sorted_target_drives) > 0) {
            $log = $log_prefix ."Drives with enough free space, but no available space: ";
            foreach ($last_resort_sorted_target_drives as $sp_drive => $space) {
                /** @noinspection PhpUndefinedVariableInspection */
                $log .= "$sp_drive (" . bytes_to_human($space*1024, FALSE) . " " . ($algo == 'most_available_space' ? 'avail' : 'used') . ") - ";
            }
            Log::debug(mb_substr($log, 0, mb_strlen($log)-2));
        }
        if (count($full_drives) > 0) {
            $log = $log_prefix ."Drives full: ";
            foreach ($full_drives as $sp_drive => $free_space) {
                $log .= "$sp_drive (" . bytes_to_human($free_space*1024, FALSE) . " free) - ";
            }
            Log::debug(mb_substr($log, 0, mb_strlen($log)-2));
        }
    }

    $sorted_target_drives = array_keys($sorted_target_drives);
    $last_resort_sorted_target_drives = array_keys($last_resort_sorted_target_drives);
    $full_drives = array_keys($full_drives);

    $drives = array_merge($sorted_target_drives, $last_resort_sorted_target_drives);
    if ($include_full_drives) {
        $drives = array_merge($drives, $full_drives);
    }

    $sticky_files = Config::get(CONFIG_STICKY_FILES);
    if (!empty($sticky_files)) {
        $is_sticky = FALSE;
        foreach ($sticky_files as $share_dir => $stick_into) {
            if (gh_wild_mb_strpos("$share/$path", $share_dir) === 0) {
                $is_sticky = TRUE;

                 $more_drives_needed = FALSE;
                if (count($stick_into) > 0) {
                    // Stick files into specific drives: $stick_into
                    // Let's check if those drives are listed in the config file!
                    foreach ($stick_into as $key => $stick_into_dir) {
                        if (!array_contains(Config::storagePoolDrives(), $stick_into_dir)) {
                            unset($stick_into[$key]);
                            $more_drives_needed = TRUE;
                        }
                    }
                }
                if (count($stick_into) == 0 || $more_drives_needed) {
                    if (string_contains($share_dir, '*')) {
                        // Contains a wildcard... In this case, we want each directory that match the wildcard to have it's own setting. Let's find this directory...
                        // For example, if $share_dir == 'Videos/Movies/*/*' and "$share/$path/" == "Videos/Movies/HD/La Vita e Bella/", we want to save a 'stick_into' setting for 'Videos/Movies/HD/La Vita e Bella/'
                        // Files in other subdirectories of Videos/Movies/HD/ could end up in other drives.
                        $needles = explode('*', $share_dir);
                        $sticky_dir = '';
                        $wild_part = "$share/$path/";
                        for ($i=0; $i<count($needles); $i++) {
                            $needle = $needles[$i];
                            if ($i == 0) {
                                $sticky_dir = $needle;
                                $wild_part = @str_replace_first($needle, '', $wild_part);
                            } else {
                                if ($needle == '') {
                                    $needle = '/';
                                }
                                $small_wild_part = mb_substr($wild_part, 0, mb_strpos($wild_part, $needle)+mb_strlen($needle));
                                $sticky_dir .= $small_wild_part;
                                $wild_part = str_replace_first($small_wild_part, '', $wild_part);
                            }
                        }
                        $sticky_dir = trim($sticky_dir, '/');
                    } else {
                        $sticky_dir = $share_dir;
                    }

                    // Stick files into any drives
                    $setting_name = sprintf('stick_into-%s', $sticky_dir);
                    $setting = Settings::get($setting_name, TRUE);
                    if ($setting) {
                        $stick_into = array_merge($stick_into, $setting);
                        // Let's check if those drives are listed in the config file!
                        $update_needed = FALSE;
                        foreach ($stick_into as $key => $stick_into_dir) {
                            if (!array_contains(Config::storagePoolDrives(), $stick_into_dir)) {
                                unset($stick_into[$key]);
                                $update_needed = TRUE;
                            }
                        }
                        if ($update_needed) {
                            $value = serialize($stick_into);
                            Settings::set($setting_name, $value);
                        }
                    } else {
                        $value = array_merge($stick_into, $drives);
                        Settings::set($setting_name, $value);
                    }
                }
                
                // Make sure the drives we want to use are not yet full and have available space
                $priority_drives = array();
                foreach ($stick_into as $stick_into_dir) {
                    if (array_contains(Config::storagePoolDrives(), $stick_into_dir)
                            && !array_contains($full_drives, $stick_into_dir)
                            && !array_contains($last_resort_sorted_target_drives, $stick_into_dir)) {
                        $priority_drives[] = $stick_into_dir;
                        unset($drives[array_search($stick_into_dir, $drives)]);
                    }
                }
                $drives = array_merge($priority_drives, $drives);
                Log::debug($log_prefix . "Reordered drives, per sticky_files config: " . implode(' - ', $drives));
                break;
            }
        }
    }

    return $drives;
}

function gh_recycle($real_path, $file_was_modified=FALSE) {
    $is_symlink = FALSE;
    clearstatcache();
    if (is_link($real_path)) {
        $is_symlink = TRUE;
    } else if (!file_exists($real_path)) {
        return TRUE;
    }

    $should_move_to_trash = FALSE;
    if (!$is_symlink) {
        $share_options = get_share_options_from_full_path($real_path);
        if ($share_options !== FALSE) {
            $full_path = trim($share_options['name'] . "/" . str_replace($share_options[CONFIG_LANDING_ZONE], '', $real_path), '/');
        } else {
            $storage_volume = get_storage_volume_from_path($real_path);
            foreach (Config::storagePoolDrives() as $sp_drive) {
                if ($sp_drive == $storage_volume) {
                    $trash_path = "$sp_drive/.gh_trash";
                    $full_path = trim(substr($real_path, strlen($sp_drive)), '/');
                    break;
                }
            }

            /** @noinspection PhpUndefinedVariableInspection */
            $share = mb_substr($full_path, 0, mb_strpos($full_path, '/'));

            if ($file_was_modified) {
                $should_move_to_trash = SharesConfig::get($share, CONFIG_MODIFIED_MOVES_TO_TRASH);
            } else {
                $should_move_to_trash = SharesConfig::get($share, CONFIG_DELETE_MOVES_TO_TRASH);
            }
        }
    }
    
    if ($should_move_to_trash) {
        // Move to trash
        if (!isset($trash_path)) {
            Log::warn("  Warning! Can't find trash for $real_path. Won't delete this file!", Log::EVENT_CODE_TRASH_NOT_FOUND);
            return FALSE;
        }

        /** @noinspection PhpUndefinedVariableInspection */
        $target_path = clean_dir("$trash_path/$full_path");

        list($path, ) = explode_full_path($target_path);

        if (@gh_is_file($path)) {
            unlink($path);
        }
        
        $dir_infos = (object) array(
            'fileowner' => 0,
            'filegroup' => 0,
            'fileperms' => (int) base_convert("0777", 8, 10)
        );
        gh_mkdir($path, $dir_infos);

        if (@is_dir($target_path)) {
            exec("rm -rf " . escapeshellarg($target_path));
        }
        if (@gh_rename($real_path, $target_path)) {
            Log::debug("  Moved copy from $real_path to trash: $target_path");
            
            // Create a symlink in the Greyhole Trash share, to allow the user to remove this file using that share
            create_trash_share_symlink($target_path, $trash_path);
            return TRUE;
        }
    } else {
        if (@unlink($real_path)) {
            if (!$is_symlink) {
                Log::debug("  Deleted copy at $real_path");
            }
            return TRUE;
        }
    }
    return FALSE;
}

function get_share_options_from_full_path($full_path) {
    $landing_zone = '';
    $share = FALSE;
    foreach (SharesConfig::getShares() as $share_name => $share_options) {
        if (string_starts_with($full_path, $share_options[CONFIG_LANDING_ZONE]) && mb_strlen($share_options[CONFIG_LANDING_ZONE]) > mb_strlen($landing_zone)) {
            $landing_zone = $share_options[CONFIG_LANDING_ZONE];
            $share = $share_options;
        }
    }
    return $share;
}

function get_storage_volume_from_path($full_path) {
    $storage_volume = FALSE;
    $longest_path_found = 0;
    foreach (Config::storagePoolDrives() as $sp_drive) {
        if (string_starts_with($full_path, $sp_drive) && mb_strlen($sp_drive) > $longest_path_found) {
            $storage_volume = $sp_drive;
            $longest_path_found = mb_strlen($sp_drive);
        } 
    }
    return $storage_volume;
}

function get_share_options_from_storage_volume($full_path, $storage_volume) {
    $landing_zone = '';
    $share = FALSE;
    foreach (SharesConfig::getShares() as $share_name => $share_options) {
        $metastore = Metastores::get_metastore_from_path($full_path);
        if ($metastore !== FALSE) {
            if (string_starts_with($full_path, "$metastore/$share_name") && mb_strlen($share_options[CONFIG_LANDING_ZONE]) > mb_strlen($landing_zone)) {
                $landing_zone = $share_options[CONFIG_LANDING_ZONE];
                $share = $share_options;
            }
        } else {
            if (string_starts_with($full_path, "$storage_volume/$share_name") && mb_strlen($share_options[CONFIG_LANDING_ZONE]) > mb_strlen($landing_zone)) {
                $landing_zone = $share_options[CONFIG_LANDING_ZONE];
                $share = $share_options;
            }
        }
    }
    return $share;
}

function gh_get_file_infos($real_path) {
    if ($real_path == null || !file_exists($real_path)) {
        return (object) array(
            'fileowner' => 0,
            'filegroup' => 0,
            'fileperms' => (int) base_convert("0777", 8, 10),
            'filemtime' => time()
        );
    }
    if (is_link($real_path)) {
        $real_path = readlink($real_path);
    }
    return (object) array(
        'fileowner' => (int) gh_fileowner($real_path),
        'filegroup' => (int) gh_filegroup($real_path),
        'fileperms' => (int) base_convert(gh_fileperms($real_path), 8, 10),
        'filemtime' => filemtime($real_path),
    );
}

function is_share_sticky($share_name) {
    $sticky_files = Config::get(CONFIG_STICKY_FILES);
    if (!empty($sticky_files)) {
        foreach ($sticky_files as $share_dir => $stick_into) {
            if (string_starts_with($share_dir, $share_name)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

function sort_storage_drives_available_space() {
    $dfs = get_free_space_in_storage_pool_drives();
    foreach (Config::storagePoolDrives() as $sp_drive) {
        if (!isset($dfs[$sp_drive])) {
            continue;
        }
        $free_space = $dfs[$sp_drive]['free'];
        $minimum_free_space = Config::get(CONFIG_MIN_FREE_SPACE_POOL_DRIVE, $sp_drive);
        $available_space = (float) $free_space - $minimum_free_space;
        while (isset($sorted_target_drives["$available_space"])) {
            // In case some drives have the exact same amount of available_space, make sure we return all drives!
            $available_space++;
        }
        // On 32-bit systems, numeric array keys can't go over 2,147,483,648, so this would overflow on drives with more available space.
        // Using string keys will prevent overflows, and it will be cast into a number later, when we use it as such.
        $sorted_target_drives["$available_space"] = $sp_drive;
    }
    ksort($sorted_target_drives);
    return $sorted_target_drives;
}

function process_config() {
    while (!ConfigHelper::parse()) {
        // Invalid config file; either it's missing storage_pool_drive, or it contains a share that isn't in smb.conf
        if (SystemHelper::is_amahi() && Log::actionIs(ACTION_DAEMON)) {
            // If running on Amahi, loop until the config works.
            // User might configure Greyhole later, and they don't want to show Greyhole 'offline' until then. Those users are easy to confuse! ;)
            sleep(600); // 10 minutes
        } else {
            // Otherwise, die.
            Log::critical("Config file parsing failed. Exiting.", Log::EVENT_CODE_CONFIG_FILE_PARSING_FAILED);
        }
    }
    // Config is OK; go on!
}

function create_trash_share_symlink($filepath_in_trash, $trash_path) {
    $trash_share = SharesConfig::getConfigForShare(CONFIG_TRASH_SHARE);
    if ($trash_share) {
        $filepath_in_trash = clean_dir($filepath_in_trash);
        $filepath_in_trash_share = str_replace($trash_path, $trash_share[CONFIG_LANDING_ZONE], $filepath_in_trash);
        if (file_exists($filepath_in_trash_share)) {
            $new_filepath = $filepath_in_trash_share;
            $i = 1;
            while (file_exists($new_filepath)) {
                if (@readlink($new_filepath) == $filepath_in_trash) {
                    // There's already a symlink to that file in the trash share; let's not make a second one!
                    return;
                }
                $new_filepath = "$filepath_in_trash_share copy $i";
                $i++;
            }
            $filepath_in_trash_share = $new_filepath;
            list(, $filename) = explode_full_path($filepath_in_trash_share);
        } else {
            list($original_path, ) = explode_full_path($filepath_in_trash);
            list($path, $filename) = explode_full_path($filepath_in_trash_share);

            $dir_infos = (object) array(
                'fileowner' => (int) gh_fileowner($original_path),
                'filegroup' => (int) gh_filegroup($original_path),
                'fileperms' => (int) base_convert("0777", 8, 10)
            );
            gh_mkdir($path, $dir_infos);
        }
        if (@gh_symlink($filepath_in_trash, $filepath_in_trash_share)) {
            Log::debug("  Created symlink to deleted file in {$trash_share['name']} share ($filename).");
        } else {
            Log::warn("  Warning! Couldn't create symlink to deleted file in {$trash_share['name']} share ($filename).", Log::EVENT_CODE_TRASH_SYMLINK_FAILED);
        }
    }
}

function remove_drive_definition($going_drive) {
    $drives_definitions = Settings::get('sp_drives_definitions', TRUE);
    if (!$drives_definitions) {
        $drives_definitions = MigrationHelper::convertStoragePoolDrivesTagFiles();
    }
    unset($drives_definitions[$going_drive]);
    Settings::set('sp_drives_definitions', $drives_definitions);
}

function get_file_inodes($share, $file_path, $filename, &$file_metafiles, $one_is_enough=FALSE) {
    $file_copies_inodes = array();

    foreach (Config::storagePoolDrives() as $sp_drive) {
        $clean_full_path = clean_dir("$sp_drive/$share/$file_path/$filename");
        if (is_link($clean_full_path)) {
            continue;
        }
        $inode_number = @gh_fileinode($clean_full_path);
        if ($inode_number !== FALSE) {
            if (is_dir($clean_full_path)) {
                Log::info("Found a directory that should be a file! Will try to remove it, if it's empty.");
                @rmdir($clean_full_path);
                continue;
            }

            Log::debug("Found $clean_full_path");

            if (!StoragePool::is_pool_drive($sp_drive)) {
                $state = Metafile::STATE_GONE;
                if (!$one_is_enough) {
                    Log::info("  Drive $sp_drive is not part of the Greyhole storage pool anymore. The above file will not be counted as a valid file copy, but can be used to create a new valid copy.");
                }
            } else {
                $state = Metafile::STATE_OK;
                $file_copies_inodes[$inode_number] = $clean_full_path;
                if ($one_is_enough) {
                    return $file_copies_inodes;
                }
            }
            if (is_string($file_metafiles)) {
                Log::critical("Fatal error! \$file_metafiles is now a string: '$file_metafiles'.", Log::EVENT_CODE_UNEXPECTED_VAR);
            }
            /** @noinspection PhpIllegalStringOffsetInspection */
            $file_metafiles[$clean_full_path] = (object) array('path' => $clean_full_path, 'is_linked' => FALSE, 'state' => $state);
            
            // Temp files leftovers of stopped Greyhole executions
            $temp_filename = get_temp_filename($clean_full_path);
            if (file_exists($temp_filename) && gh_is_file($temp_filename)) {
                Log::info("  Found temporary file $temp_filename ... deleting.");
                $fsck_report['temp_files'][] = $temp_filename;
                unlink($temp_filename);
            }
        }
    }

    return $file_copies_inodes;
}

?>
